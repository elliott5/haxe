// Copyright 2014 Elliott Stoneham and The TARDIS Go Authors
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

// Package haxegoruntime is automatically included in every TARDIS Go transpilation.
// This Go code is used by the Haxe runtime, it must be entirely self-sufficent.
// This Go code is always in the runtime. TODO consider how to slim it down...
package haxegoruntime // long name so as not to clash

import (
	"unicode/utf16"
	"unicode/utf8"
)

// init() needs to reference all of the functions used by the Haxe as part of the runtime
// so that  they are not removed during Go-level dead code elimination.
func init() {
	_ = ZiLen
	_ = UTF16toRunes(nil)
	_ = UTF8toRunes(nil)
	_ = Raw2Runes(nil)
	_ = RunesToUTF16(nil)
	_ = RunesToUTF8(nil)
	_ = Runes2Raw(nil)
	_ = Rune2Raw(42)
	_ = StringCompare("X", "Y")

	_ = utf16.Decode(nil)
	_ = utf8.RuneCount(nil)
	_, _ = utf8.DecodeRune(nil)
	_ = utf16.Encode(nil)
	_ = utf8.RuneLen(42)
}

// ZiLen is the runtime native string length of the chinese character "字", meaning "written character", which is pronounced "zi" in Mandarin.
// It is initialised by the haxe Go.init() code generated by goclass.go: ZiLen = uint(hxutil.HAXE("'字'.length;"))
var ZiLen uint

// UTF16toRunes is a wrapper for utf16.Decode
func UTF16toRunes(s []uint16) []rune {
	return utf16.Decode(s)
}

// UTF8toRunes takes a utf8 byte slice and returns the equivalent rune slice
func UTF8toRunes(s []byte) []rune { // TODO rewrite to use sub-slices (now that the system supports them)
	ret := make([]rune, utf8.RuneCount(s))
	si := 0
	for ri := 0; si < len(s) && ri < len(ret); ri++ {
		p := make([]byte, len(s)-si)
		for j := 0; j < (len(s) - si); j++ {
			p[j] = s[si+j]
		}
		aRune, size := utf8.DecodeRune(p)
		ret[ri] = aRune
		si += size
	}
	return ret
}

// Raw2Runes takes a plaform-specific integer slice representing a string and returns the equivalent rune slice
func Raw2Runes(s []int) []rune {
	switch ZiLen {
	case 1: // UTF-16 encoding
		var tmp = make([]uint16, len(s))
		for t := range s {
			tmp[t] = uint16(s[t])
		}
		return UTF16toRunes(tmp)
	case 3: // UTF-8 encoding
		var tmp = make([]byte, len(s))
		for t := range s {
			tmp[t] = byte(s[t])
		}
		return UTF8toRunes(tmp)
	default:
		// can't go panic() because we are in the runtime
	}
	return []rune{} // vet flags this as unreachable
}

// RunesToUTF16 is a wrapper for utf16.Encode
func RunesToUTF16(r []rune) []uint16 {
	return utf16.Encode(r)
}

// RunesToUTF8 takes a rune slice and returns the equivalent utf8 byte slice
func RunesToUTF8(r []rune) []byte {
	var ret []byte
	ret = make([]byte, 0)
	for i := range r {
		buf := make([]byte, utf8.RuneLen(r[i]))
		utf8.EncodeRune(buf, r[i])
		ret = append(ret, buf...)
	}
	return ret
}

// Runes2Raw takes a rune slice and returns a platform-specific integer slice representing the underlying string
func Runes2Raw(r []rune) []int {
	switch ZiLen {
	case 1: // UTF-16 encoding
		retUint16 := RunesToUTF16(r)
		var tmpIntS = make([]int, len(retUint16))
		for tmpI := range retUint16 {
			tmpIntS[tmpI] = int(retUint16[tmpI])
		}
		return tmpIntS
	case 3: // UTF-8 encoding
		retUint8 := RunesToUTF8(r)
		var tmpIntS = make([]int, len(retUint8))
		for tmpI := range retUint8 {
			tmpIntS[tmpI] = int(retUint8[tmpI])
		}
		return tmpIntS
	default:
		// can't go panic() because we are in the runtime
	}
	return []int{} // vet flags this as unreachable
}

// Rune2Raw takes an individual rune and returns the platform-specific integer slice representing it
func Rune2Raw(oneRune rune) []int { // make a string from a single rune
	r := make([]rune, 1)
	r[0] = oneRune
	return Runes2Raw(r)
}

// StringCompare is called by the code generator to ensure that only UTF8 encoding is used in string comparisons
func StringCompare(a, b string) int {
	//println("DEBUG:StringCompare", a, b)
	x := []byte(a)
	y := []byte(b)
	i := 0
	for (i < len(x)) && (i < len(y)) {
		if x[i] < y[i] {
			return -1
		}
		if x[i] > y[i] {
			return +1
		}
		i++
	}
	if len(x) == len(y) {
		return 0
	}
	if len(x) < len(y) {
		return -1
	}
	return +1
}
